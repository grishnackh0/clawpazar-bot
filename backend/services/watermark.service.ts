// ClawPazar â€“ AI Content Watermark Service
// Handles EXIF injection, steganographic watermarks, content hashing, and disclosure badges
// Required by: Turkish AI content disclosure regulations

import crypto from 'crypto';

// ============================================================
// TYPES
// ============================================================

interface WatermarkResult {
    contentHash: string;       // SHA-256 of original content
    watermarkHash: string;     // SHA-256 of watermark payload
    isDisclosed: boolean;      // always true for compliance
    metadata: WatermarkMetadata;
}

interface WatermarkMetadata {
    ai_generated: boolean;
    ai_model: string;
    generated_at: string;
    platform: 'clawpazar';
    content_type: 'image' | 'text' | 'description';
    disclosure_text_tr: string;
    disclosure_text_en: string;
}

interface ImageWatermarkOptions {
    imageBuffer: Buffer;
    aiModel: string;
    listingId?: string;
    contentType: 'image';
}

interface TextWatermarkOptions {
    text: string;
    aiModel: string;
    listingId?: string;
    contentType: 'text' | 'description';
}

// ============================================================
// CONSTANTS
// ============================================================

const DISCLOSURE_TR = 'Yapay Zeka TarafÄ±ndan ÃœretilmiÅŸtir';
const DISCLOSURE_EN = 'Generated by Artificial Intelligence';
const PLATFORM_ID = 'clawpazar';

// EXIF IFD0 tag for AI generation marker (using UserComment field)
// EXIF spec: Tag 0x9286 (UserComment)
const EXIF_MARKER_TAG = 'AI-Generated';

// Invisible Unicode steganographic markers (zero-width characters)
const STEG_MARKERS = {
    START: '\u200B\u200C\u200D\uFEFF',  // Zero-width space + ZWNJ + ZWJ + BOM
    END: '\uFEFF\u200D\u200C\u200B',
    ZERO: '\u200B',   // zero-width space = binary 0
    ONE: '\u200C',    // zero-width non-joiner = binary 1
};

// ============================================================
// WATERMARK SERVICE
// ============================================================

export class WatermarkService {

    // ----------------------------------------------------------
    // 1. IMAGE WATERMARKING
    // ----------------------------------------------------------

    /**
     * Apply watermark to an AI-generated image.
     * Strategy:
     *  1. Inject EXIF metadata (AI-Generated: true)
     *  2. Compute content hash (SHA-256)
     *  3. Generate watermark hash for verification
     *
     * Note: Full steganographic watermarking (pixel-level) requires
     *       a native library (e.g., StegaStamp). This implementation
     *       focuses on metadata-level watermarking which is tamper-evident.
     */
    async watermarkImage(options: ImageWatermarkOptions): Promise<{
        watermarkedBuffer: Buffer;
        result: WatermarkResult;
    }> {
        const contentHash = this.hashContent(options.imageBuffer);
        const metadata = this.createMetadata(options.aiModel, options.contentType);
        const watermarkHash = this.hashContent(Buffer.from(JSON.stringify(metadata)));

        // Create EXIF comment payload
        const exifComment = JSON.stringify({
            [EXIF_MARKER_TAG]: true,
            platform: PLATFORM_ID,
            model: options.aiModel,
            date: metadata.generated_at,
            hash: watermarkHash,
            disclosure: DISCLOSURE_TR,
        });

        // Inject EXIF marker into image buffer
        // For JPEG: inject into APP1 (EXIF) segment
        // For PNG: inject into tEXt chunk
        const watermarkedBuffer = this.injectExifComment(options.imageBuffer, exifComment);

        return {
            watermarkedBuffer,
            result: {
                contentHash,
                watermarkHash,
                isDisclosed: true,
                metadata,
            },
        };
    }

    // ----------------------------------------------------------
    // 2. TEXT WATERMARKING (Steganographic)
    // ----------------------------------------------------------

    /**
     * Apply invisible steganographic watermark to AI-generated text.
     * Uses zero-width Unicode characters to embed a binary signature.
     * The original text appears unchanged to humans.
     */
    watermarkText(options: TextWatermarkOptions): {
        watermarkedText: string;
        result: WatermarkResult;
    } {
        const contentHash = this.hashContent(Buffer.from(options.text, 'utf-8'));
        const metadata = this.createMetadata(options.aiModel, options.contentType);
        const watermarkHash = this.hashContent(Buffer.from(JSON.stringify(metadata)));

        // Encode watermark hash as zero-width characters
        const binarySignature = this.textToBinary(watermarkHash.substring(0, 16)); // first 16 chars
        const steganographicMark = this.encodeSteganographic(binarySignature);

        // Insert invisible watermark at a natural break point (after first sentence)
        const insertionPoint = this.findInsertionPoint(options.text);
        const watermarkedText =
            options.text.substring(0, insertionPoint) +
            steganographicMark +
            options.text.substring(insertionPoint);

        return {
            watermarkedText,
            result: {
                contentHash,
                watermarkHash,
                isDisclosed: true,
                metadata,
            },
        };
    }

    // ----------------------------------------------------------
    // 3. VERIFICATION
    // ----------------------------------------------------------

    /**
     * Verify if text contains a steganographic watermark.
     */
    verifyTextWatermark(text: string): {
        hasWatermark: boolean;
        extractedSignature: string | null;
    } {
        const startIdx = text.indexOf(STEG_MARKERS.START);
        const endIdx = text.indexOf(STEG_MARKERS.END);

        if (startIdx === -1 || endIdx === -1 || endIdx <= startIdx) {
            return { hasWatermark: false, extractedSignature: null };
        }

        const encoded = text.substring(
            startIdx + STEG_MARKERS.START.length,
            endIdx
        );

        const extractedSignature = this.decodeSteganographic(encoded);

        return {
            hasWatermark: true,
            extractedSignature,
        };
    }

    /**
     * Verify image watermark by reading EXIF comment.
     */
    verifyImageWatermark(imageBuffer: Buffer): {
        hasWatermark: boolean;
        metadata: object | null;
    } {
        const exifComment = this.extractExifComment(imageBuffer);

        if (!exifComment) {
            return { hasWatermark: false, metadata: null };
        }

        try {
            const parsed = JSON.parse(exifComment);
            return {
                hasWatermark: parsed[EXIF_MARKER_TAG] === true,
                metadata: parsed,
            };
        } catch {
            return { hasWatermark: false, metadata: null };
        }
    }

    // ----------------------------------------------------------
    // 4. DISCLOSURE BADGE DATA
    // ----------------------------------------------------------

    /**
     * Get the disclosure information to display in the UI.
     * Must be shown on all AI-generated content.
     */
    static getDisclosureBadge(contentType: 'image' | 'text' | 'description'): {
        emoji: string;
        text_tr: string;
        text_en: string;
        cssClass: string;
    } {
        return {
            emoji: 'ðŸ¤–',
            text_tr: DISCLOSURE_TR,
            text_en: DISCLOSURE_EN,
            cssClass: 'ai-disclosure-badge',
        };
    }

    // ----------------------------------------------------------
    // INTERNAL HELPERS
    // ----------------------------------------------------------

    private createMetadata(aiModel: string, contentType: 'image' | 'text' | 'description'): WatermarkMetadata {
        return {
            ai_generated: true,
            ai_model: aiModel,
            generated_at: new Date().toISOString(),
            platform: PLATFORM_ID,
            content_type: contentType,
            disclosure_text_tr: DISCLOSURE_TR,
            disclosure_text_en: DISCLOSURE_EN,
        };
    }

    private hashContent(buffer: Buffer): string {
        return crypto.createHash('sha256').update(buffer).digest('hex');
    }

    private textToBinary(text: string): string {
        return Array.from(text)
            .map((char) => char.charCodeAt(0).toString(2).padStart(8, '0'))
            .join('');
    }

    private encodeSteganographic(binaryString: string): string {
        const encoded = Array.from(binaryString)
            .map((bit) => (bit === '0' ? STEG_MARKERS.ZERO : STEG_MARKERS.ONE))
            .join('');
        return STEG_MARKERS.START + encoded + STEG_MARKERS.END;
    }

    private decodeSteganographic(encoded: string): string {
        const binary = Array.from(encoded)
            .map((char) => {
                if (char === STEG_MARKERS.ZERO) return '0';
                if (char === STEG_MARKERS.ONE) return '1';
                return '';
            })
            .join('');

        // Convert binary back to text (8 bits per char)
        const chars: string[] = [];
        for (let i = 0; i < binary.length; i += 8) {
            const byte = binary.substring(i, i + 8);
            if (byte.length === 8) {
                chars.push(String.fromCharCode(parseInt(byte, 2)));
            }
        }
        return chars.join('');
    }

    private findInsertionPoint(text: string): number {
        // Insert after first sentence (. ! ?) or after 100 chars
        const sentenceEnd = text.search(/[.!?]\s/);
        if (sentenceEnd > 0 && sentenceEnd < 200) {
            return sentenceEnd + 2; // after the punctuation and space
        }
        // Fallback: after first space past 50 chars
        const spaceAfter50 = text.indexOf(' ', 50);
        return spaceAfter50 > 0 ? spaceAfter50 + 1 : text.length;
    }

    /**
     * Inject EXIF comment into JPEG buffer.
     * Simplified: writes JSON comment into JPEG COM marker (0xFFFE).
     */
    private injectExifComment(imageBuffer: Buffer, comment: string): Buffer {
        const commentBytes = Buffer.from(comment, 'utf-8');
        // JPEG COM marker: FF FE [length_hi] [length_lo] [comment_data]
        const markerLength = commentBytes.length + 2; // +2 for length bytes
        const comMarker = Buffer.alloc(4 + commentBytes.length);
        comMarker[0] = 0xFF;
        comMarker[1] = 0xFE;
        comMarker[2] = (markerLength >> 8) & 0xFF;
        comMarker[3] = markerLength & 0xFF;
        commentBytes.copy(comMarker, 4);

        // Check if it's a JPEG (starts with FF D8)
        if (imageBuffer[0] === 0xFF && imageBuffer[1] === 0xD8) {
            // Insert COM marker right after SOI (FF D8)
            return Buffer.concat([
                imageBuffer.subarray(0, 2),  // SOI
                comMarker,
                imageBuffer.subarray(2),     // rest of JPEG
            ]);
        }

        // For non-JPEG (PNG etc.), append as a custom chunk or return as-is
        // In production, use a proper PNG tEXt chunk writer
        return imageBuffer;
    }

    /**
     * Extract EXIF/COM comment from JPEG buffer.
     */
    private extractExifComment(imageBuffer: Buffer): string | null {
        // Scan for JPEG COM marker (FF FE)
        for (let i = 0; i < imageBuffer.length - 4; i++) {
            if (imageBuffer[i] === 0xFF && imageBuffer[i + 1] === 0xFE) {
                const length = (imageBuffer[i + 2] << 8) | imageBuffer[i + 3];
                const commentData = imageBuffer.subarray(i + 4, i + 2 + length);
                return commentData.toString('utf-8');
            }
        }
        return null;
    }
}

// ============================================================
// FACTORY
// ============================================================

export function createWatermarkService(): WatermarkService {
    return new WatermarkService();
}
